//! 类型转换示例程序
//! 
//! 本程序演示了 Rust 中不同类型之间的显式类型转换，
//! 特别是浮点数到整数以及整数到字符的转换过程。
//! 同时展示了溢出行为和模运算在类型转换中的应用。

// 不显示类型转换产生的溢出警告
#![allow(overflowing_literals)]

fn main() {
    // 创建一个 32 位浮点数变量，值为 65.4321
    let decimal = 65.4321_f32;

    // 错误！不提供隐式转换
    // Rust 不会自动进行类型转换，必须显式使用 as 关键字
    //let integer: u8 = decimal;

    // 使用显式类型转换将浮点数转换为 u8（无符号 8 位整数）
    // 这会截断小数部分，只保留整数部分
    let integer = decimal as u8;
    
    // 将 u8 值转换为字符
    // 这会将数字 65 映射到 ASCII 字符 'A'
    let character = integer as char;

    // 打印类型转换的完整过程
    // 输出格式：原始值 -> 转换后值 -> 最终字符
    println!("Casting: {} -> {} -> {}", decimal, integer, character);

    // 示例：将 1000 转换为 u16（无符号 16 位整数）
    // 1000 在 u16 范围内（0 到 65535），所以转换成功
    println!("1000 as a u16 is: {}", 1000 as u16);

    // 示例：将 1000 转换为 u8（无符号 8 位整数）
    // 1000 超出 u8 范围（0 到 255），会发生溢出
    // 结果是 1000 % 256 = 232
    println!("1000 as a u8 is : {}", 1000 as u8);

    // 示例：将 -1i8 转换为 u8
    // i8 范围是 -128 到 127，-1 在范围内
    // 转换为 u8 时，-1 会变成 255（有符号到无符号的转换）
    println!(" -1 as a u8 is : {}", (-1i8) as u8);

    // 演示模运算：1000 mod 256
    // 这解释了为什么 1000 转换为 u8 时得到 232
    println!("1000 mod 256 is : {}", 1000 % 256);

    // 示例：将 128 转换为 i16（有符号 16 位整数）
    // 128 在 i16 范围内（-32768 到 32767），转换成功
    println!(" 128 as i16 is: {}", 128 as i16);
    
    // 示例：将 128 转换为 i8（有符号 8 位整数）
    // 128 超出 i8 范围（-128 到 127），会发生溢出
    // 结果是 128 % 256 = 128，但符号位被截断，变成 -128
    println!(" 128 as i8 is: {}", 128 as i8);

    // 示例：将 1000 转换为 u8（重复演示）
    // 再次确认溢出行为
    println!("1000 as u8 is : {}", 1000 as u8);
    
    // 示例：将 232 转换为 i8
    // 232 超出 i8 正常范围（0 到 127），但仍在 u8 范围内
    // 转换为 i8 时，232 % 256 = 232，但符号扩展后变成 -24
    println!(" 232 as i8 is : {}", 232 as i8);
}
